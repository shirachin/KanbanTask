---
alwaysApply: true
---
# プロジェクト構成の設計思想

このプロジェクトは、FastAPI（バックエンド）、Vue.js（フロントエンド）、PostgreSQL（データベース）で構成されるタスク管理アプリケーションです。

## アーキテクチャの設計原則

### バックエンドの設計思想

1. **レイヤー分離**: APIルーター層 → サービス層 → モデル層の順で依存関係を明確にする
   - 上位レイヤーは下位レイヤーに依存するが、逆方向の依存は避ける
   - 各レイヤーは明確な責任を持つ

2. **関心の分離**:
   - **APIルーター層**: HTTPリクエスト/レスポンスの処理、ルーティング
   - **サービス層**: ビジネスロジック、データ変換、トランザクション管理
   - **モデル層**: データベーススキーマ定義、ORMモデル
   - **スキーマ層**: データバリデーション、シリアライゼーション

3. **依存性注入**: FastAPIの依存性注入を活用し、テスト容易性と柔軟性を確保
   - サービス層のロジックを依存性として注入し、モック化を容易にする

4. **バージョン管理**: APIはバージョン付きプレフィックスで管理し、将来のバージョンアップに対応
   - 既存のAPIを壊さずに新機能を追加できる設計

5. **エラーハンドリング**: カスタム例外を使用し、一貫したエラーレスポンスを返す
   - エラーの種類に応じた適切なHTTPステータスコードとメッセージ

6. **データベースマイグレーション**: スキーマ変更はマイグレーションツールで管理
   - バージョン管理されたスキーマ変更により、環境間の一貫性を保つ

7. **トランザクション管理**: データベース操作はトランザクション内で実行
   - エラー発生時は自動的にロールバック
   - トランザクション管理ユーティリティを活用し、一貫性を保つ

8. **ロギング**: 適切なログレベルでエラーや重要な操作を記録
   - 本番環境では機密情報を含まないように注意
   - エラーの詳細はログに記録し、ユーザーには適切なメッセージを返す

9. **API設計**: RESTful APIの原則に従う
   - 適切なHTTPメソッド（GET, POST, PUT, DELETE）を使用
   - 一貫したレスポンス形式を維持
   - エラーレスポンスは統一された形式で返す

### フロントエンドの設計思想

1. **コンポーネント設計**: 単一責任の原則に従い、再利用可能なコンポーネントを作成
   - 各コンポーネントは明確な役割と責任を持つ
   - ページコンポーネントとUIコンポーネントを分離

2. **Composition API**: Vue 3のComposition APIを積極的に使用
   - ロジックの再利用性とテスタビリティを向上
   - Options APIよりも柔軟な状態管理とライフサイクル管理

3. **関心の分離**:
   - **ビジネスロジック**: コンポジション関数（composables）に配置
   - **UIロジック**: コンポーネント内に配置
   - **型定義**: 型定義ファイルに集約
   - **ユーティリティ**: 純粋関数としてユーティリティファイルに配置

4. **型安全性**: TypeScriptを活用し、型定義を適切に管理
   - APIレスポンスの型定義を維持し、コンパイル時エラーを検出
   - 型推論を活用し、冗長な型注釈を避ける

5. **状態管理**: 必要に応じて状態管理ライブラリを使用
   - グローバル状態とローカル状態を適切に分離
   - コンポジション関数で状態管理ロジックをカプセル化

6. **エラーハンドリング**: ユーザーフレンドリーなエラーメッセージを表示
   - API呼び出し時のエラーは適切にキャッチし、ユーザーに通知
   - ローディング状態とエラー状態を明確に管理
   - ネットワークエラーやサーバーエラーを区別して処理

7. **非同期処理**: async/awaitを適切に使用
   - エラーハンドリングを必ず実装（try-catch）
   - ローディング状態を適切に管理
   - 複数の非同期処理を並列実行する場合はPromise.allを活用

8. **バリデーション**: フロントエンドとバックエンドの両方で実装
   - フロントエンド: ユーザー体験向上のための即座のフィードバック
   - バックエンド: セキュリティとデータ整合性の確保
   - バリデーションロジックは可能な限り共通化

9. **UIコンポーネントライブラリ**: Atlassian Design Systemを使用
   - 一貫したデザインシステムに基づいたUIコンポーネントを活用
   - アクセシビリティとユーザビリティを確保
   - カスタムコンポーネントを作成する場合は、デザインシステムの原則に従う
   - 既存のコンポーネントライブラリを優先的に使用し、必要に応じて拡張

## コード配置の原則

### バックエンド

- **APIエンドポイント追加時**:
  - ルーター層にエンドポイントを定義
  - ビジネスロジックはルーター層に直接実装（サービス層は必要に応じて導入）
  - スキーマ層にリクエスト/レスポンスの型定義を追加
  - 必要に応じてモデル層にデータモデルを追加
  - 複雑なロジックが増えた場合は、サービス層への移行を検討

- **データモデル追加時**:
  - モデル層にORMモデルを定義
  - スキーマ層にPydanticスキーマを定義
  - マイグレーションファイルを生成

- **共通機能追加時**:
  - コア機能層に共通設定やユーティリティを配置
  - 複数のサービスで使用される機能は共通化

### フロントエンド

- **ページ追加時**:
  - ページコンポーネントを作成
  - 必要に応じてUIコンポーネントを作成
  - 型定義を追加
  - API呼び出しロジックをコンポジション関数に配置

- **機能追加時**:
  - 再利用可能なロジックはコンポジション関数に配置
  - UIコンポーネントは再利用可能な形で設計
  - 定数は定数ファイルに集約
  - ユーティリティ関数は純粋関数として実装

- **UIコンポーネント作成時**:
  - Atlassian Design Systemのコンポーネントを優先的に使用
  - デザインシステムにない場合は、デザインシステムの原則に従ってカスタムコンポーネントを作成
  - コンポーネントのスタイリングはデザインシステムのトークン（色、スペーシング、タイポグラフィなど）を使用

## 命名規則

### バックエンド

- **ファイル名**: スネークケース
- **クラス名**: パスカルケース
- **関数名**: スネークケース
- **定数**: 大文字のスネークケース
- **変数名**: スネークケース

### フロントエンド

- **コンポーネントファイル名**: パスカルケース
- **コンポーネント名**: パスカルケース
- **関数名**: キャメルケース
- **定数**: 大文字のスネークケース
- **変数名**: キャメルケース
- **型名**: パスカルケース

## 設計パターン

### バックエンド

- **Repository パターン**: データアクセス層を抽象化（必要に応じて）
- **Service パターン**: ビジネスロジックをサービス層に集約
- **DTO パターン**: スキーマ層でデータ転送オブジェクトを定義

### フロントエンド

- **Composition パターン**: コンポジション関数でロジックを再利用
- **Container/Presentational パターン**: コンテナコンポーネントとプレゼンテーションコンポーネントを分離（必要に応じて）
- **Custom Hooks パターン**: コンポジション関数でカスタムフックを実装

## データベース設計の原則

1. **リレーションシップ**: 適切な外部キー制約とリレーションシップを定義
   - 一対多、多対多の関係を明確にする
   - カスケード削除は慎重に使用（データ整合性を考慮）

2. **トランザクション**: 複数のデータベース操作はトランザクション内で実行
   - エラー発生時は自動的にロールバック
   - トランザクション管理ユーティリティを使用

3. **データ整合性**: データベース制約を活用
   - NOT NULL制約、UNIQUE制約、外部キー制約を適切に設定
   - アプリケーションレベルとデータベースレベルの両方で整合性を保つ

4. **クエリ最適化**: パフォーマンスを考慮したクエリ設計
   - N+1問題を避けるため、必要に応じてeager loading（joinedload, selectinload）を使用
   - インデックスを適切に設定（外部キー、検索条件に使用されるカラム）
   - ページネーションを実装し、大量データの取得を避ける
   - 不要なデータの取得を避け、必要なカラムのみを選択

## エラーハンドリングの原則

### バックエンド

1. **例外の階層化**: カスタム例外を使用し、エラーの種類を明確に区別
2. **ユーザーフレンドリーなメッセージ**: 技術的なエラー詳細はログに記録し、ユーザーには分かりやすいメッセージを返す
3. **HTTPステータスコード**: 適切なHTTPステータスコードを使用（400, 404, 422, 500など）
4. **一貫したレスポンス形式**: エラーレスポンスは統一された形式で返す

### フロントエンド

1. **エラー状態の管理**: コンポジション関数でエラー状態を管理
2. **ユーザーへの通知**: エラー発生時はユーザーに適切な方法で通知（アラート、トーストなど）
3. **ローディング状態**: 非同期処理中はローディング状態を表示
4. **リトライ機能**: ネットワークエラーなど一時的なエラーにはリトライ機能を検討

## コード品質の原則

1. **DRY原則**: 重複コードを避け、共通化を積極的に行う
2. **単一責任の原則**: 各関数、クラス、コンポーネントは単一の責任を持つ
3. **可読性**: コードは読みやすく、意図が明確であること
4. **コメント**: 複雑なロジックには適切なコメントを追加
5. **型安全性**: TypeScript/Pydanticを活用し、型安全性を確保

## API設計の詳細原則

### バックエンド

1. **レスポンスモデルの使用**: すべてのエンドポイントで`response_model`を指定
   - 型安全性とAPIドキュメントの自動生成を確保
   - レスポンス形式の一貫性を保つ

2. **クエリパラメータの設計**: フィルタリング、ページネーション、ソートを適切に実装
   - オプショナルパラメータは`Optional`型を使用
   - デフォルト値を適切に設定（ページネーションのlimitなど）

3. **エラーハンドリングの統一**: 各エンドポイントで一貫したエラーハンドリングを実装
   - データベースエラーは適切にキャッチし、ロールバック
   - ユーザーフレンドリーなエラーメッセージを返す
   - トランザクション管理ユーティリティを活用

4. **ドキュメント化**: すべてのエンドポイントにdocstringを追加
   - エンドポイントの目的、パラメータ、レスポンスを明確に記述
   - FastAPIの自動ドキュメント生成を活用

### フロントエンド

1. **API呼び出しの共通化**: 可能な限り共通のAPIクライアント関数を使用
   - エラーハンドリング、リトライ、ローディング状態の管理を統一
   - 認証トークンなどの共通ヘッダーを一元管理

2. **型定義の維持**: APIレスポンスの型定義を常に最新に保つ
   - バックエンドのスキーマ変更に合わせて型定義を更新
   - 型安全性を活用し、コンパイル時エラーを検出

3. **状態管理の一貫性**: コンポジション関数で状態管理を統一
   - ローディング状態、エラー状態、データ状態を明確に管理
   - 状態の更新は一箇所で行い、予測可能な動作を保つ

## パフォーマンス最適化の原則

1. **データベースクエリの最適化**:
   - 必要なデータのみを取得（SELECT句の明示）
   - リレーションシップの読み込みはeager loadingを検討
   - インデックスを適切に設定

2. **フロントエンドの最適化**:
   - 不要な再レンダリングを避ける（computed、watchの適切な使用）
   - 大量データの表示には仮想スクロールを検討
   - 画像やアセットの最適化

3. **API呼び出しの最適化**:
   - 並列実行可能なAPI呼び出しは`Promise.all`を使用
   - キャッシュを適切に活用（必要に応じて）
   - 不要なAPI呼び出しを避ける

## 保守性向上の原則

1. **コードの複雑度管理**: 関数やメソッドが複雑になりすぎないようにする
   - 複雑な条件分岐は早期リターンやガード句を使用
   - 長い関数は適切に分割

2. **リファクタリング**: コードの重複や複雑さが増えた場合は積極的にリファクタリング
   - サービス層への移行を検討（ビジネスロジックが複雑になった場合）
   - 共通処理の抽出

3. **後方互換性**: APIの変更時は後方互換性を考慮
   - 既存のエンドポイントを壊さないように注意
   - バージョン管理を活用
